\documentclass{tufte-handout}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage{mathpazo}
\usepackage{booktabs}
\usepackage{microtype}

\pagestyle{empty}


\title{Closest Pair Report}
\author{Martino Secchi, Ivan Naumovski, and SÃ¸ren Palmund}

\begin{document}
\[\maketitle

  \section{Results}

  Our implementation produces the expected results on all input--output file pairs.

  The following table shows the closest pairs in some of the input files {\tt wc-instance-*.txt}.
  Here $n$ denotes the number of points in the input,
  and distance $\delta$.

  \bigskip\noindent
  \begin{tabular}{rr}\toprule
    $n$ & $\delta$ \\\midrule
    2 & 1.0 \\
    254 & 1.0 \\
    16382 & 1.0 \\
    65534 & 1.0 \\\bottomrule
  \end{tabular}


  \section{Implementation details}
    
  \subsection{Walkthrough}
  
  We call the method \verb+ClosestPair+ which takes as input a list of points sorted by X-values $input$, and returns the smallest distance between two of those points and a list of the same points sorted by Y-values. \newline

  $Tuple<Double, List<EPoint> > ClosestPair( List<EPoint> input )$
  
  The method examines the number of points that are in $input$ list.\newline

  If there are only 3 points then we compute the smallest distance between them, and return it alongside with a list of the 3 points sorted by Y-values.\newline
  
  If there are 2 points then we simply return the distance between them and a list containing the two points sorted by Y-value.\newline
  
  In any other case we compute the median $m$ and split $input$ into two smaller subsets:\newline

  $Q = \lbrack 0..m \lbrack $\newline
  $R = \lbrack m..input.size \lbrack$ \newline 

  We then call \verb+ClosestPair+ recursively to get the smallest distance on the left side $d_{left}$ and on the right side $d_{right}$.

We then set the delta $\delta = min(d_{left}, d_{right})$.\newline

We then merge the two lists of Y-sorted points returned from the $Q$ and $R$ branches, which results in the $recombine$ list, and sort it so it will remain Y-sorted. We use the built in $sort$ method to sort the $recombine$ list.\newline

Using $\delta$ we compute the range on the X-axis around $m$ (in the range $m \pm \delta$) which might hold pairs that are closer than what we've found so far.
To help with this we compute upper bound and lower bounds on the X-values.\newline
 Between these bounds, for each point in the $recombine$ list that doesn't exceed the bounds on the X axis, we'll compare the distance between the point and the 15 points that come after it in Y order.
If the distance is smaller than $\delta$ we update $\delta$ to be the smallest one.

\subsection{Run time}
    Our running time is $O(n\log n)$ for $n$ points.


\]
\end{document}